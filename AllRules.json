{"constants":[{"id":"constant-1","name":"QTEST_TOKEN","hidden":false,"value":""},{"id":"constant-2","name":"SCENARIO_PROJECT_ID","hidden":false,"value":""},{"id":"constant-3","name":"ManagerURL","hidden":false,"value":""},{"id":"constant-4","name":"SlackWebHook","hidden":false,"value":""},{"id":"constant-5","name":"JenkinsUserName","hidden":false,"value":""},{"id":"constant-6","name":"JenkinsAPIToken","hidden":false,"value":""},{"id":"constant-7","name":"JenkinsURL","hidden":false,"value":""},{"id":"constant-8","name":"JenkinsJobName","hidden":false,"value":""},{"id":"constant-9","name":"JenkinsJobToken","hidden":false,"value":""}],"actions":[{"id":"action-1","name":"FormatJavaCucumber","description":null,"code":"const { Webhooks } = require('@qasymphony/pulse-sdk');\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n\n    // Payload to be passed in: json style cucumber for java test results\n\n    /////// Pulse version\n    var payload = body;\n    var testResults = payload.result;\n    var projectId = payload.projectId;\n    var cycleId = payload[\"test-cycle\"];\n\n    //////// Commandline version\n    //var fs = require('fs');\n    //var testResults = JSON.parse(fs.readFileSync('/Users/elise/Repos/cucumber-bdd/target/cucumber-report.json', 'utf8'));\n    //var projectId = 60676; // Pulse Automation Project\n    //var cycleId = 821416; // Pulse Automation Project\n    /// TODO: Remove above\n\n    var testLogs = [];\n    //console.log(\"TEST RESULTS: \" + testResults);\n\n    //emitEvent('SlackEvent', { TESTRESULTS: testResults });\n\n    testResults.forEach(function (feature) {\n        var featureName = feature.name;\n        feature.elements.forEach(function (testCase) {\n\n            if (!testCase.name)\n                testCase.name = \"Unnamed\";\n\n            TCStatus = \"passed\";\n\n            var reportingLog = {\n                exe_start_date: new Date(), // TODO These could be passed in\n                exe_end_date: new Date(),\n                module_names: [\n                    'Test Scenarios'\n                ],\n                name: testCase.name,\n                automation_content: feature.uri + \"#\" + testCase.name\n            };\n\n            var testStepLogs = [];\n            order = 0;\n            stepNames = [];\n            attachments = [];\n\n            testCase.steps.forEach(function (step) {\n                stepNames.push(step.name);\n\n                var status = step.result.status;\n                var actual = step.name;\n\n                if (TCStatus == \"passed\" && status == \"skipped\") {\n                    TCStatus = \"skipped\";\n                }\n                if (status == \"failed\") {\n                    TCStatus = \"failed\";\n                    actual = step.result.error_message;\n                }\n                if (status == \"undefined\") {\n                    TCStatus = \"failed\";\n                    status = \"failed\";\n                }\n\n                // Are there an attachment for this step?\n                if (\"embeddings\" in step) {\n                    console.log(\"Has attachment\");\n\n                    attCount = 0;\n                    step.embeddings.forEach(function (att) {\n                        attCount++;\n                        var attachment = {\n                            name: step.name + \" Attachment \" + attCount,\n                            \"content_type\": att.mime_type,\n                            data: att.data\n                        };\n                        console.log(\"Attachment: \" + attachment.name)\n\n                        attachments.push(attachment);\n                    });\n                }\n\n                var expected = step.keyword + \" \" + step.name;\n\n                if (\"location\" in step.match) {\n                    expected = step.match.location;\n                }\n\n                var stepLog = {\n                    order: order,\n                    description: step.name,\n                    expected_result: step.keyword,\n                    actual_result: actual,\n                    status: status\n                };\n\n                testStepLogs.push(stepLog);\n                order++;\n            });\n\n            reportingLog.attachments = attachments;\n            reportingLog.description = stepNames.join(\"<br/>\");\n            reportingLog.status = TCStatus;\n            reportingLog.test_step_logs = testStepLogs;\n            reportingLog.featureName = featureName;\n            testLogs.push(reportingLog);\n        });\n    });\n\n    var formattedResults = {\n        \"projectId\": projectId,\n        \"test-cycle\": cycleId,\n        \"logs\": testLogs\n    };\n\n\n    // Pulse Version\n    // Emit next fxn to upload results/parse\n    emitEvent('UpdateQTestAndScenarioWithFormattedResultsEvent', formattedResults);\n\n    /// Command line version\n    // Write new file\n    //var payload = fs.writeFile('formattedResults.json', JSON.stringify(formattedResults, null, \"  \" ), 'utf8', function() {\n    //    console.log(\"File written: formattedResults.json\");\n    //});\n}\n"},{"id":"action-2","name":"FormatPostmanJson","description":null,"code":"const { Webhooks } = require('@qasymphony/pulse-sdk');\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n\n    // Payload to be passed in: json style cucumber for java test results\n\n    /////// Pulse version\n    var payload = body;\n    var testResults = payload.result;\n    var projectId = payload.projectId;\n    var cycleId = payload[\"test-cycle\"];\n\n    var collectionName = testResults.collection.info.name;\n    var testLogs = [];\n\n    testResults.run.executions.forEach(function (testCase) {\n\n        var featureName = testCase.item.name;\n\n        TCStatus = \"passed\";\n        var reportingLog = {\n            exe_start_date: new Date(), // TODO These could be passed in\n            exe_end_date: new Date(),\n            module_names: [\n                'Postman'\n            ],\n            name: testCase.item.name,\n            automation_content: collectionName + \"#\" + testCase.item.name // TODO See if ID is static or when that changes\n        };\n\n        var testStepLogs = [];\n        order = 0;\n        stepNames = [];\n\n        if (!(\"assertions\" in testCase)) {\n            return;\n        }\n\n        testCase.assertions.forEach(function (step) {\n            stepNames.push(step.assertion);\n            stepErrorVal = \"passed\";\n\n            var actual = step.assertion;\n\n            if (\"error\" in step) {\n                stepErrorVal = \"failed\";\n                TCStatus = \"failed\";\n                actual = step.error.message;\n            }\n\n            var stepLog = {\n                order: order,\n                description: step.assertion,\n                expected_result: step.assertion,\n                status: stepErrorVal,\n                actual_result: actual\n            };\n\n            testStepLogs.push(stepLog);\n            order++;\n        });\n\n        reportingLog.description = \"Created by Pulse\"; // testCase.request;\n        reportingLog.status = TCStatus;\n        reportingLog.test_step_logs = testStepLogs;\n        reportingLog.featureName = featureName;\n        testLogs.push(reportingLog);\n\n    });\n\n    var formattedResults = {\n        \"projectId\": projectId,\n        \"test-cycle\": cycleId,\n        \"logs\": testLogs\n    };\n\n\n    // Pulse Version\n    emitEvent('$YOUR_UPLOAD_TO_QTEST_EVENT_URL', formattedResults);\n}\n"},{"id":"action-3","name":"FormatPythonPyTestJUnit","description":null,"code":"const { Webhooks } = require('@qasymphony/pulse-sdk');\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n\n    /////// Pulse version\n    var payload = body;\n    var testResults = payload.result;\n    var projectId = payload.projectId;\n    var cycleId = payload[\"test-cycle\"];\n\n    xml2js = require('xml2js');\n\n    //////// Commandline version\n    // var fs = require('fs');\n    //\n    // var projectId = 12345;\n    // var cycleId = 12341234;\n    /// TODO: Remove above\n\n    var testLogs = [];\n    function FormatLogs(tr) {\n\n        var testResults = JSON.parse(tr);\n        testResults.testsuite.testcase.forEach(function (tc) {\n            var tcResult = tc[\"$\"];\n            var tcName = \"\";\n\n            // Format the name\n            var note = \"\";\n            if (!tcResult.name)\n                tcName = \"Unnamed\";\n            else\n                tcName = tcResult.name.substring(0, tcResult.name.indexOf('['));\n            note = tcResult.name;\n\n            TCStatus = \"PASS\";\n\n            if (tc.failure) {\n                TCStatus = \"FAIL\";\n                if (note)\n                    note = \"\\n\" + JSON.stringify(tc.failure);\n                else\n                    note = JSON.stringify(tc.failure);\n            }\n\n            // The automation content is what we're going to use to run this later so it's important to get that format for Python pytest\n            //$file :: $classname (after the last .) :: $name (before the [)\n            var tcShortClassName = tcResult.classname.substring(tcResult.classname.lastIndexOf('.') + 1)\n            var auto = tcResult.file + \"::\" + tcShortClassName + \"::\" + tcName;\n\n            var reportingLog = {\n                exe_start_date: new Date(), // TODO this could use the time to complete to be more precise\n                exe_end_date: new Date(),\n                module_names: [\n                    'JUnitTests'\n                ],\n                name: tcName,\n                automation_content: auto,\n                note: note\n            };\n\n            // There are no steps here, so we'll add one step entry\n            var testStepLogs = [{\n                order: 0,\n                description: tcName,\n                expected_result: tcName,\n                status: TCStatus\n            }];\n\n            reportingLog.description = \"Test case imported from Python Test\"\n            reportingLog.status = TCStatus;\n            reportingLog.test_step_logs = testStepLogs;\n            testLogs.push(reportingLog);\n        });\n\n        var formattedResults = {\n            \"projectId\": projectId,\n            \"test-cycle\": cycleId,\n            \"logs\": testLogs\n        };\n\n        return formattedResults;\n    }\n\n    // Pulse Version\n    var parser = new xml2js.Parser();\n    parser.parseString(testResults, function (err, result) {\n        var formattedResults = FormatLogs(JSON.stringify(result));\n        emitEvent('$YOUR_UPLOAD_TO_QTEST_EVENT_URL', formattedResults);\n    });\n\n    /// Command line version\n    // fs.readFile('results.xml', function(err, data) {\n    //     parser.parseString(data, function (err, result) {\n    //         var formattedResults = FormatLogs(JSON.stringify(result));\n    //         Write new file\n    //         var payload = fs.writeFile('formattedResults.json', JSON.stringify(formattedResults, null, \"  \" ), 'utf8', function() {\n    //             console.log(\"File written: formattedResults.json\");\n    //         });\n    //     });\n    // });\n}\n"},{"id":"action-4","name":"LinkScenarioRequirements","description":null,"code":"const request = require('request');\nconst { Webhooks } = require('@qasymphony/pulse-sdk');\nconst ScenarioSdk = require('@qasymphony/scenario-sdk');\n\nconst Features = {\n    getIssueLinkByFeatureName(qtestToken, scenarioProjectId, name) {\n        return new ScenarioSdk.Features({ qtestToken, scenarioProjectId }).getFeatures(`\"${name}\"`);\n    }\n};\n\nexports.handler = async function ({ event: body, constants, triggers }, context, callback) {\n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n\n    // Specific to pulse actions\n    var payload = body;\n\n    var testLogs = payload.logs;\n    var projectId = payload.projectId;\n\n    var standardHeaders = {\n        'Content-Type': 'application/json',\n        'Authorization': `bearer ${constants.QTEST_TOKEN}`\n    }\n\n    // This makes a best effort to link if test cases exist. Not if you just uploaded via the auto-test-logs endpoint, the job is batched and may not be completed yet\n    testLogs.forEach(function (testcase) {\n\n        var feat = await Features.getIssueLinkByFeatureName(constants.QTEST_TOKEN, constants.SCENARIO_PROJECT_ID, testcase.featureName);\n\n        if (feat.length === 0) // No corresponding feature exists in scenario\n            return;\n\n        feat.forEach(function (matchingFeature) {\n\n            var reqopts = getReqBody(matchingFeature.issueKey);\n            request.post(reqopts, function (err, response, featureResBody) {\n\n                if (err) {\n                    emitEvent('$YOUR_SLACK_EVENT_NAME', { Error: \"Problem getting requirement: \" + err });\n                }\n                else {\n                    if (featureResBody.items.length === 0) // No corresponding feature exists in scenario\n                        return;\n\n                    var reqid = featureResBody.items[0].id;\n                    var tcopts = getTCBody(testcase.name);\n\n                    request.post(tcopts, function (tcerr, tcresponse, testCaseResBody) {\n\n                        if (tcerr) {\n                            emitEvent('$YOUR_SLACK_EVENT_NAME', { Error: \"Problem getting test case: \" + err });\n                        }\n                        else {\n                            var tcid = testCaseResBody.items[0].id;\n                            var linkopts = getLinkBody(reqid, tcid);\n\n                            request.post(linkopts, function (optserr, optsresponse, resbody) {\n                                if (optserr) {\n                                    emitEvent('$YOUR_SLACK_EVENT_NAME', { Error: \"Problem creating test link to requirement: \" + err });\n                                }\n                                else {\n                                    // Success, we added a link!\n                                    emitEvent('$YOUR_SLACK_EVENT_NAME', { Linking: \"link added for TC: \" + testcase.name + \" to requirement \" + matchingFeature.issueKey });\n                                }\n                            });\n                        }\n                    });\n                }\n            });\n        });\n\n    });\n\n\n    function getTCBody(TCName) {\n        return {\n            url: \"https://\" + constants.ManagerURL + \"/api/v3/projects/\" + projectId + \"/search\",\n            json: true,\n            headers: standardHeaders,\n            body: {\n                \"object_type\": \"test-cases\",\n                \"fields\": [\n                    \"*\"\n                ],\n                \"query\": \"Name = '\" + TCName + \"'\"\n            }\n        };\n    }\n\n    function getReqBody(key) {\n        return {\n            url: \"https://\" + constants.ManagerURL + \"/api/v3/projects/\" + projectId + \"/search\",\n            json: true,\n            headers: standardHeaders,\n            body: {\n                \"object_type\": \"requirements\",\n                \"fields\": [\n                    \"*\"\n                ],\n                \"query\": \"Name ~ '\" + key + \"'\"\n            }\n        };\n    }\n\n    function getLinkBody(reqid, tcid) {\n        return {\n            url: \"https://\" + constants.ManagerURL + \"/api/v3/projects/\" + projectId + \"/requirements/\" + reqid + \"/link?type=test-cases\",\n            json: true,\n            headers: standardHeaders,\n            body: [\n                tcid\n            ]\n        };\n    }\n}\n"},{"id":"action-5","name":"scenarioColors","description":null,"code":"const ScenarioSdk = require('@qasymphony/scenario-sdk');\n\nconst Steps = {\n    updateStepResults(qtestToken, scenarioProjectId, name, status) {\n        let stepSdk = new ScenarioSdk.Steps({ qtestToken, scenarioProjectId });\n        return stepSdk.getSteps(`\"${name}\"`).then(steps => Promise.all(steps.map(step => stepSdk.updateStep(step.id, Object.assign(step, { status })))));\n    }\n};\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    var payload = body;\n    var testLogs = payload.logs;\n\n    for (var res of testLogs) {\n        for (var step of res[\"test_step_logs\"]) {\n            var stepName = step.description;\n            var stepStatus = step.status;\n\n            // Undefined means no step definition existed and it should fail\n            if (stepStatus == \"undefined\") {\n                stepStatus = \"failed\";\n            }\n\n            // one of PASSED (green), FAILED (red), or SKIPPED (yellow)\n            var stepStatus = _.upperCase(stepStatus);\n\n            // Call the pulse API to update step results\n            Steps.updateStepResults(constants.QTEST_TOKEN, constants.SCENARIO_PROJECT_ID, stepName, stepStatus);\n        }\n    }\n}\n"},{"id":"action-6","name":"SlackAction","description":null,"code":"exports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    var str = body;\n\n    var request = require('request');\n    var slack_webhook = constants.SlackWebHook;\n\n    console.log('About to request slack webhook: ', slack_webhook);\n\n    request({\n        uri: slack_webhook,\n        method: 'POST',\n        json: { \"text\": JSON.stringify(str) }\n    }, function (error, response, body) { }\n    );\n}\n"},{"id":"action-7","name":"triggerJenkins","description":null,"code":"const request = require('request');\nconst { Webhooks } = require('@qasymphony/pulse-sdk');\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n\n    var url = \"http://\" + constants.JenkinsUserName + \":\" + constants.JenkinsAPIToken + \"@\" +\n        constants.JenkinsURL + '/crumbIssuer/api/xml?xpath=concat(//crumbRequestField,\":\",//crumb)';\n\n    request.get({ url: url, insecure: true }, function (err, response, body) {\n        if (!err) {\n            var crumb = body.split(\":\")[1];\n\n            var joburl = \"http://\" + constants.JenkinsUserName + \":\" + constants.JenkinsAPIToken + \"@\" +\n                constants.JenkinsURL + \"/job/\" + constants.JenkinsJobName + \"/build?token=\" + constants.JenkinsJobToken\n            var opts = {\n                url: joburl,\n                insecure: true,\n                contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n                headers: {\n                    \"Jenkins-Crumb\": crumb\n                }\n            }\n\n            request.post(opts, function (err, res, bd) {\n                emitEvent('$YOUR_SLACK_EVENT_NAME', { JenkinsCallSuccess: \"Jenkins Build just kicked off for project \" + constants.JenkinsJobName });\n            })\n        }\n    })\n}\n"},{"id":"action-8","name":"UpdateQTestWithFormattedResults","description":null,"code":"const request = require('request');\nconst { Webhooks } = require('@qasymphony/pulse-sdk');\nconst ScenarioSdk = require('@qasymphony/scenario-sdk');\n\nconst Features = {\n    getIssueLinkByFeatureName(qtestToken, scenarioProjectId, name) {\n        return new ScenarioSdk.Features({ qtestToken, scenarioProjectId }).getFeatures(`\"${name}\"`);\n    }\n};\n\nexports.handler = function ({ event: body, constants, triggers }, context, callback) {\n    function emitEvent(name, payload) {\n        let t = triggers.find(t => t.name === name);\n        return t && new Webhooks().invoke(t, payload);\n    }\n\n    // Specific to pulse actions\n    var payload = body;\n\n    var testLogs = payload.logs;\n    var cycleId = payload[\"test-cycle\"];\n    var projectId = payload.projectId;\n\n    var scenarioCount = 0;\n    var scenarioList = \"\";\n\n    var standardHearders = {\n        'Content-Type': 'application/json',\n        'Authorization': `bearer ${constants.QTEST_TOKEN}`\n    }\n\n    var createLogsAndTCs = function () {\n        var opts = {\n            url: \"http://\" + constants.ManagerURL + \"/api/v3/projects/\" + projectId + \"/auto-test-logs?type=automation\",\n            json: true,\n            headers: standardHearders,\n            body: {\n                test_cycle: cycleId,\n                test_logs: testLogs\n            }\n        };\n\n        return request.post(opts, function (err, response, resbody) {\n\n            if (err) {\n                Promise.reject(err);\n            }\n            else {\n                emitEvent('SlackEvent', { AutomationLogUploaded: resbody });\n\n                if (response.body.type == \"AUTOMATION_TEST_LOG\") {\n                    Promise.resolve(\"Uploaded results successfully\");\n                }\n                else {\n                    emitEvent('SlackEvent', { Error: \"Wrong type\" });\n                    Promise.reject(\"Unable to upload test results\");\n                }\n            }\n        });\n    };\n\n\n    // TODO: This makes a best effort to link. If the TCs aren't uploaded yet, this won't work, but will on subsequent tries\n    var linkReq = function () {\n\n        testLogs.forEach(async function (testcase) {\n            var feat = await Features.getIssueLinkByFeatureName(constants.QTEST_TOKEN, constants.SCENARIO_PROJECT_ID, testcase.featureName);\n\n            if (feat.length === 0) // No corresponding feature exists in scenario\n                return;\n\n            var reqopts = getReqBody(feat[0].issueKey);\n            request.post(reqopts, function (err, response, featureResBody) {\n                if (err) {\n                    reject(err);\n                }\n                else {\n\n                    var reqid = featureResBody.items[0].id;\n\n                    // Grab the cooresponding test case ID\n                    var tcopts = getTCBody(testcase.name);\n                    request.post(tcopts, function (err, response, testCaseResBody) {\n                        if (err) {\n                            reject(err);\n                        }\n                        else {\n                            var tcid = testCaseResBody.items[0].id;\n                            var opts = getLinkBody(reqid, tcid);\n\n                            request.post(opts, function (err, response, resbody) {\n                                if (err) {\n                                    reject(err);\n                                }\n                                else {\n                                    // Success, we added a link!\n                                    emitEvent('SlackEvent', { Linking: \"link added for TC: \" + testcase.name + \" to requirement \" + feat[0].issueKey });\n                                }\n                            });\n                        }\n                    });\n                }\n            });\n        });\n    };\n\n    function getTCBody(TCName) {\n        return {\n            url: \"https://\" + constants.ManagerURL + \"/api/v3/projects/\" + projectId + \"/search\",\n            json: true,\n            headers: standardHearders,\n            body: {\n                \"object_type\": \"test-cases\",\n                \"fields\": [\n                    \"*\"\n                ],\n                \"query\": \"Name = '\" + TCName + \"'\"\n            }\n        };\n    }\n\n    function getReqBody(key) {\n        return {\n            url: \"https://\" + constants.ManagerURL + \"/api/v3/projects/\" + projectId + \"/search\",\n            json: true,\n            headers: standardHearders,\n            body: {\n                \"object_type\": \"requirements\",\n                \"fields\": [\n                    \"*\"\n                ],\n                \"query\": \"Name ~ '\" + key + \"'\"\n            }\n        };\n    }\n\n    function getLinkBody(reqid, tcid) {\n        return {\n            url: \"https://\" + constants.ManagerURL + \"/api/v3/projects/\" + projectId + \"/requirements/\" + reqid + \"/link?type=test-cases\",\n            json: true,\n            headers: standardHeaders,\n            body: [\n                tcid\n            ]\n        };\n    }\n\n    createLogsAndTCs()\n        .on('response', function () {\n            linkReq();\n        })\n        .on('error', function (err) {\n            emitEvent('SlackEvent', { CaughtError: err });\n        })\n}\n"}],"triggers":[{"id":"trigger-1","name":"LinkScenarioRequirements"},{"id":"trigger-2","name":"scenarioColors"},{"id":"trigger-3","name":"triggerJenkins"},{"id":"trigger-4","name":"SlackEvent"},{"id":"trigger-5","name":"UpdateQTestWithFormattedResultsEvent"},{"id":"trigger-6","name":"UploadPythonJUnitResults"},{"id":"trigger-7","name":"UploadJavaCucumberResults"}],"rules":[{"id":"rule-8","name":"triggerJenkins","active":true,"triggerId":"trigger-3","actionIds":["action-7"],"tags":[]},{"id":"rule-9","name":"MessageSlack","active":true,"triggerId":"trigger-4","actionIds":["action-6"],"tags":[]},{"id":"rule-10","name":"ParseAndUploadPostmanJsonTestResults","active":true,"triggerId":"trigger-4","actionIds":["action-2"],"tags":[]},{"id":"rule-11","name":"UploadJavaCucumberResultsWithScenario","active":true,"triggerId":"trigger-5","actionIds":["action-5","action-8"],"tags":[]},{"id":"rule-12","name":"LinkTestCasesToRequirementsWithScenario","active":true,"triggerId":"trigger-1","actionIds":["action-4"],"tags":[]},{"id":"rule-13","name":"ParseAndUploadPythonPyTestResults","active":true,"triggerId":"trigger-6","actionIds":["action-3"],"tags":[]},{"id":"rule-14","name":"UploadJavaCucumberResults","active":true,"triggerId":"trigger-7","actionIds":["action-1"],"tags":[]}]}